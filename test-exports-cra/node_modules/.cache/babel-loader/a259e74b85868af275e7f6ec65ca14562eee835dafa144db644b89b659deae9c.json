{"ast":null,"code":"import { Document } from \"./document.js\";\nexport class TextSplitter {\n  constructor(fields) {\n    Object.defineProperty(this, \"chunkSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1000\n    });\n    Object.defineProperty(this, \"chunkOverlap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 200\n    });\n    this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n    this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n    if (this.chunkOverlap >= this.chunkSize) {\n      throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n    }\n  }\n  async createDocuments(texts) {\n    let metadatas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});\n    const documents = new Array();\n    for (let i = 0; i < texts.length; i += 1) {\n      const text = texts[i];\n      let lineCounterIndex = 1;\n      let prevChunk = null;\n      for (const chunk of await this.splitText(text)) {\n        // we need to count the \\n that are in the text before getting removed by the splitting\n        let numberOfIntermediateNewLines = 0;\n        if (prevChunk) {\n          const indexChunk = text.indexOf(chunk);\n          const indexEndPrevChunk = text.indexOf(prevChunk) + prevChunk.length;\n          const removedNewlinesFromSplittingText = text.slice(indexEndPrevChunk, indexChunk);\n          numberOfIntermediateNewLines = (removedNewlinesFromSplittingText.match(/\\n/g) || []).length;\n        }\n        lineCounterIndex += numberOfIntermediateNewLines;\n        const newLinesCount = (chunk.match(/\\n/g) || []).length;\n        const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\" ? {\n          ..._metadatas[i].loc\n        } : {};\n        loc.lines = {\n          from: lineCounterIndex,\n          to: lineCounterIndex + newLinesCount\n        };\n        const metadataWithLinesNumber = {\n          ..._metadatas[i],\n          loc\n        };\n        documents.push(new Document({\n          pageContent: chunk,\n          metadata: metadataWithLinesNumber\n        }));\n        lineCounterIndex += newLinesCount;\n        prevChunk = chunk;\n      }\n    }\n    return documents;\n  }\n  async splitDocuments(documents) {\n    const texts = documents.map(doc => doc.pageContent);\n    const metadatas = documents.map(doc => doc.metadata);\n    return this.createDocuments(texts, metadatas);\n  }\n  joinDocs(docs, separator) {\n    const text = docs.join(separator).trim();\n    return text === \"\" ? null : text;\n  }\n  mergeSplits(splits, separator) {\n    const docs = [];\n    const currentDoc = [];\n    let total = 0;\n    for (const d of splits) {\n      const _len = d.length;\n      if (total + _len >= this.chunkSize) {\n        if (total > this.chunkSize) {\n          console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n        }\n        if (currentDoc.length > 0) {\n          const doc = this.joinDocs(currentDoc, separator);\n          if (doc !== null) {\n            docs.push(doc);\n          }\n          // Keep on popping if:\n          // - we have a larger chunk than in the chunk overlap\n          // - or if we still have any chunks and the length is long\n          while (total > this.chunkOverlap || total + _len > this.chunkSize && total > 0) {\n            total -= currentDoc[0].length;\n            currentDoc.shift();\n          }\n        }\n      }\n      currentDoc.push(d);\n      total += _len;\n    }\n    const doc = this.joinDocs(currentDoc, separator);\n    if (doc !== null) {\n      docs.push(doc);\n    }\n    return docs;\n  }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\\n\\n\"\n    });\n    this.separator = fields?.separator ?? this.separator;\n  }\n  async splitText(text) {\n    // First we naively split the large input into a bunch of smaller ones.\n    let splits;\n    if (this.separator) {\n      splits = text.split(this.separator);\n    } else {\n      splits = text.split(\"\");\n    }\n    return this.mergeSplits(splits, this.separator);\n  }\n}\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separators\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n    });\n    this.separators = fields?.separators ?? this.separators;\n  }\n  async splitText(text) {\n    const finalChunks = [];\n    // Get appropriate separator to use\n    let separator = this.separators[this.separators.length - 1];\n    for (const s of this.separators) {\n      if (s === \"\") {\n        separator = s;\n        break;\n      }\n      if (text.includes(s)) {\n        separator = s;\n        break;\n      }\n    }\n    // Now that we have the separator, split the text\n    let splits;\n    if (separator) {\n      splits = text.split(separator);\n    } else {\n      splits = text.split(\"\");\n    }\n    // Now go merging things, recursively splitting longer texts.\n    let goodSplits = [];\n    for (const s of splits) {\n      if (s.length < this.chunkSize) {\n        goodSplits.push(s);\n      } else {\n        if (goodSplits.length) {\n          const mergedText = this.mergeSplits(goodSplits, separator);\n          finalChunks.push(...mergedText);\n          goodSplits = [];\n        }\n        const otherInfo = await this.splitText(s);\n        finalChunks.push(...otherInfo);\n      }\n    }\n    if (goodSplits.length) {\n      const mergedText = this.mergeSplits(goodSplits, separator);\n      finalChunks.push(...mergedText);\n    }\n    return finalChunks;\n  }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"encodingName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"allowedSpecial\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"disallowedSpecial\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tokenizer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"registry\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.encodingName = fields?.encodingName ?? \"gpt2\";\n    this.allowedSpecial = fields?.allowedSpecial ?? [];\n    this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n  }\n  async splitText(text) {\n    if (!this.tokenizer) {\n      const tiktoken = await TokenTextSplitter.imports();\n      this.tokenizer = tiktoken.get_encoding(this.encodingName);\n      // We need to register a finalizer to free the tokenizer when the\n      // splitter is garbage collected.\n      this.registry = new FinalizationRegistry(t => t.free());\n      this.registry.register(this, this.tokenizer);\n    }\n    const splits = [];\n    const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n    let start_idx = 0;\n    let cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n    let chunk_ids = input_ids.slice(start_idx, cur_idx);\n    const decoder = new TextDecoder();\n    while (start_idx < input_ids.length) {\n      splits.push(decoder.decode(this.tokenizer.decode(chunk_ids)));\n      start_idx += this.chunkSize - this.chunkOverlap;\n      cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n      chunk_ids = input_ids.slice(start_idx, cur_idx);\n    }\n    return splits;\n  }\n  static async imports() {\n    try {\n      return await import(\"@dqbd/tiktoken\");\n    } catch (err) {\n      console.error(err);\n      throw new Error(\"Please install @dqbd/tiktoken as a dependency with, e.g. `npm install -S @dqbd/tiktoken`\");\n    }\n  }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separators\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\n      // First, try to split along Markdown headings (starting with level 2)\n      \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \", \"\\n###### \",\n      // Note the alternative syntax for headings (below) is not handled here\n      // Heading level 2\n      // ---------------\n      // End of code block\n      \"```\\n\\n\",\n      // Horizontal lines\n      \"\\n\\n***\\n\\n\", \"\\n\\n---\\n\\n\", \"\\n\\n___\\n\\n\",\n      // Note that this splitter doesn't handle horizontal lines defined\n      // by *three or more* of ***, ---, or ___, but this is not handled\n      \"\\n\\n\", \"\\n\", \" \", \"\"]\n    });\n  }\n}","map":{"version":3,"names":["Document","TextSplitter","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","chunkSize","chunkOverlap","Error","createDocuments","texts","metadatas","arguments","length","undefined","_metadatas","Array","fill","documents","i","text","lineCounterIndex","prevChunk","chunk","splitText","numberOfIntermediateNewLines","indexChunk","indexOf","indexEndPrevChunk","removedNewlinesFromSplittingText","slice","match","newLinesCount","loc","lines","from","to","metadataWithLinesNumber","push","pageContent","metadata","splitDocuments","map","doc","joinDocs","docs","separator","join","trim","mergeSplits","splits","currentDoc","total","d","_len","console","warn","shift","CharacterTextSplitter","split","RecursiveCharacterTextSplitter","separators","finalChunks","s","includes","goodSplits","mergedText","otherInfo","TokenTextSplitter","encodingName","allowedSpecial","disallowedSpecial","tokenizer","tiktoken","imports","get_encoding","registry","FinalizationRegistry","t","free","register","input_ids","encode","start_idx","cur_idx","Math","min","chunk_ids","decoder","TextDecoder","decode","err","error","MarkdownTextSplitter"],"sources":["/Users/b/Code/langchainjs/test-exports-cra/node_modules/langchain/dist/text_splitter.js"],"sourcesContent":["import { Document } from \"./document.js\";\nexport class TextSplitter {\n    constructor(fields) {\n        Object.defineProperty(this, \"chunkSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        Object.defineProperty(this, \"chunkOverlap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 200\n        });\n        this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n        this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    async createDocuments(texts, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadatas = []) {\n        const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});\n        const documents = new Array();\n        for (let i = 0; i < texts.length; i += 1) {\n            const text = texts[i];\n            let lineCounterIndex = 1;\n            let prevChunk = null;\n            for (const chunk of await this.splitText(text)) {\n                // we need to count the \\n that are in the text before getting removed by the splitting\n                let numberOfIntermediateNewLines = 0;\n                if (prevChunk) {\n                    const indexChunk = text.indexOf(chunk);\n                    const indexEndPrevChunk = text.indexOf(prevChunk) + prevChunk.length;\n                    const removedNewlinesFromSplittingText = text.slice(indexEndPrevChunk, indexChunk);\n                    numberOfIntermediateNewLines = (removedNewlinesFromSplittingText.match(/\\n/g) || []).length;\n                }\n                lineCounterIndex += numberOfIntermediateNewLines;\n                const newLinesCount = (chunk.match(/\\n/g) || []).length;\n                const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\"\n                    ? { ..._metadatas[i].loc }\n                    : {};\n                loc.lines = {\n                    from: lineCounterIndex,\n                    to: lineCounterIndex + newLinesCount,\n                };\n                const metadataWithLinesNumber = {\n                    ..._metadatas[i],\n                    loc,\n                };\n                documents.push(new Document({\n                    pageContent: chunk,\n                    metadata: metadataWithLinesNumber,\n                }));\n                lineCounterIndex += newLinesCount;\n                prevChunk = chunk;\n            }\n        }\n        return documents;\n    }\n    async splitDocuments(documents) {\n        const texts = documents.map((doc) => doc.pageContent);\n        const metadatas = documents.map((doc) => doc.metadata);\n        return this.createDocuments(texts, metadatas);\n    }\n    joinDocs(docs, separator) {\n        const text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    }\n    mergeSplits(splits, separator) {\n        const docs = [];\n        const currentDoc = [];\n        let total = 0;\n        for (const d of splits) {\n            const _len = d.length;\n            if (total + _len >= this.chunkSize) {\n                if (total > this.chunkSize) {\n                    console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n                }\n                if (currentDoc.length > 0) {\n                    const doc = this.joinDocs(currentDoc, separator);\n                    if (doc !== null) {\n                        docs.push(doc);\n                    }\n                    // Keep on popping if:\n                    // - we have a larger chunk than in the chunk overlap\n                    // - or if we still have any chunks and the length is long\n                    while (total > this.chunkOverlap ||\n                        (total + _len > this.chunkSize && total > 0)) {\n                        total -= currentDoc[0].length;\n                        currentDoc.shift();\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += _len;\n        }\n        const doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        this.separator = fields?.separator ?? this.separator;\n    }\n    async splitText(text) {\n        // First we naively split the large input into a bunch of smaller ones.\n        let splits;\n        if (this.separator) {\n            splits = text.split(this.separator);\n        }\n        else {\n            splits = text.split(\"\");\n        }\n        return this.mergeSplits(splits, this.separator);\n    }\n}\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n        });\n        this.separators = fields?.separators ?? this.separators;\n    }\n    async splitText(text) {\n        const finalChunks = [];\n        // Get appropriate separator to use\n        let separator = this.separators[this.separators.length - 1];\n        for (const s of this.separators) {\n            if (s === \"\") {\n                separator = s;\n                break;\n            }\n            if (text.includes(s)) {\n                separator = s;\n                break;\n            }\n        }\n        // Now that we have the separator, split the text\n        let splits;\n        if (separator) {\n            splits = text.split(separator);\n        }\n        else {\n            splits = text.split(\"\");\n        }\n        // Now go merging things, recursively splitting longer texts.\n        let goodSplits = [];\n        for (const s of splits) {\n            if (s.length < this.chunkSize) {\n                goodSplits.push(s);\n            }\n            else {\n                if (goodSplits.length) {\n                    const mergedText = this.mergeSplits(goodSplits, separator);\n                    finalChunks.push(...mergedText);\n                    goodSplits = [];\n                }\n                const otherInfo = await this.splitText(s);\n                finalChunks.push(...otherInfo);\n            }\n        }\n        if (goodSplits.length) {\n            const mergedText = this.mergeSplits(goodSplits, separator);\n            finalChunks.push(...mergedText);\n        }\n        return finalChunks;\n    }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"encodingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"allowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"disallowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tokenizer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"registry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.encodingName = fields?.encodingName ?? \"gpt2\";\n        this.allowedSpecial = fields?.allowedSpecial ?? [];\n        this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n    }\n    async splitText(text) {\n        if (!this.tokenizer) {\n            const tiktoken = await TokenTextSplitter.imports();\n            this.tokenizer = tiktoken.get_encoding(this.encodingName);\n            // We need to register a finalizer to free the tokenizer when the\n            // splitter is garbage collected.\n            this.registry = new FinalizationRegistry((t) => t.free());\n            this.registry.register(this, this.tokenizer);\n        }\n        const splits = [];\n        const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n        let start_idx = 0;\n        let cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n        let chunk_ids = input_ids.slice(start_idx, cur_idx);\n        const decoder = new TextDecoder();\n        while (start_idx < input_ids.length) {\n            splits.push(decoder.decode(this.tokenizer.decode(chunk_ids)));\n            start_idx += this.chunkSize - this.chunkOverlap;\n            cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n            chunk_ids = input_ids.slice(start_idx, cur_idx);\n        }\n        return splits;\n    }\n    static async imports() {\n        try {\n            return await import(\"@dqbd/tiktoken\");\n        }\n        catch (err) {\n            console.error(err);\n            throw new Error(\"Please install @dqbd/tiktoken as a dependency with, e.g. `npm install -S @dqbd/tiktoken`\");\n        }\n    }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ]\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}