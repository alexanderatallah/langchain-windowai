{"ast":null,"code":"import { LLMChain } from \"../../chains/llm_chain.js\";\nimport { Agent } from \"../agent.js\";\nimport { SystemMessagePromptTemplate, HumanMessagePromptTemplate, ChatPromptTemplate, MessagesPlaceholder } from \"../../prompts/chat.js\";\nimport { renderTemplate } from \"../../prompts/template.js\";\nimport { PREFIX, SUFFIX, FORMAT_INSTRUCTIONS, TEMPLATE_TOOL_RESPONSE } from \"./prompt.js\";\nimport { AIChatMessage, HumanChatMessage, BaseOutputParser } from \"../../schema/index.js\";\nexport class ChatConversationalAgentOutputParser extends BaseOutputParser {\n  async parse(text) {\n    let jsonOutput = text.trim();\n    if (jsonOutput.includes(\"```json\")) {\n      jsonOutput = jsonOutput.split(\"```json\")[1].trimStart();\n    }\n    if (jsonOutput.includes(\"```\")) {\n      jsonOutput = jsonOutput.split(\"```\")[0].trimEnd();\n    }\n    if (jsonOutput.startsWith(\"```\")) {\n      jsonOutput = jsonOutput.slice(3).trimStart();\n    }\n    if (jsonOutput.endsWith(\"```\")) {\n      jsonOutput = jsonOutput.slice(0, -3).trimEnd();\n    }\n    const response = JSON.parse(jsonOutput);\n    return {\n      action: response.action,\n      action_input: response.action_input\n    };\n  }\n  getFormatInstructions() {\n    return FORMAT_INSTRUCTIONS;\n  }\n}\n/**\n * Agent for the MRKL chain.\n * @augments Agent\n */\nexport class ChatConversationalAgent extends Agent {\n  constructor(input, outputParser) {\n    super(input);\n    Object.defineProperty(this, \"outputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.outputParser = outputParser ?? new ChatConversationalAgentOutputParser();\n  }\n  _agentType() {\n    /** Not turning on serialization until more sure of abstractions. */\n    throw new Error(\"Method not implemented.\");\n  }\n  observationPrefix() {\n    return \"Observation: \";\n  }\n  llmPrefix() {\n    return \"Thought:\";\n  }\n  _stop() {\n    return [\"Observation:\"];\n  }\n  static validateTools(tools) {\n    const invalidTool = tools.find(tool => !tool.description);\n    if (invalidTool) {\n      const msg = `Got a tool ${invalidTool.name} without a description.` + ` This agent requires descriptions for all tools.`;\n      throw new Error(msg);\n    }\n  }\n  constructScratchPad(steps) {\n    const thoughts = [];\n    for (const step of steps) {\n      thoughts.push(new AIChatMessage(step.action.log));\n      thoughts.push(new HumanChatMessage(renderTemplate(TEMPLATE_TOOL_RESPONSE, \"f-string\", {\n        observation: step.observation\n      })));\n    }\n    return thoughts;\n  }\n  /**\n   * Create prompt in the style of the zero shot agent.\n   *\n   * @param tools - List of tools the agent will have access to, used to format the prompt.\n   * @param args - Arguments to create the prompt with.\n   * @param args.suffix - String to put after the list of tools.\n   * @param args.prefix - String to put before the list of tools.\n   */\n  static createPrompt(tools, args) {\n    const {\n      systemMessage = PREFIX,\n      humanMessage = SUFFIX,\n      outputParser = new ChatConversationalAgentOutputParser()\n    } = args ?? {};\n    const toolStrings = tools.map(tool => `${tool.name}: ${tool.description}`).join(\"\\n\");\n    const formatInstructions = renderTemplate(humanMessage, \"f-string\", {\n      format_instructions: outputParser.getFormatInstructions()\n    });\n    const toolNames = tools.map(tool => tool.name).join(\"\\n\");\n    const finalPrompt = renderTemplate(formatInstructions, \"f-string\", {\n      tools: toolStrings,\n      tool_names: toolNames\n    });\n    const messages = [SystemMessagePromptTemplate.fromTemplate(systemMessage), new MessagesPlaceholder(\"chat_history\"), HumanMessagePromptTemplate.fromTemplate(finalPrompt), new MessagesPlaceholder(\"agent_scratchpad\")];\n    return ChatPromptTemplate.fromPromptMessages(messages);\n  }\n  static fromLLMAndTools(llm, tools, args) {\n    ChatConversationalAgent.validateTools(tools);\n    const prompt = ChatConversationalAgent.createPrompt(tools, args);\n    const chain = new LLMChain({\n      prompt,\n      llm\n    });\n    const {\n      outputParser = new ChatConversationalAgentOutputParser()\n    } = args ?? {};\n    return new ChatConversationalAgent({\n      llmChain: chain,\n      allowedTools: tools.map(t => t.name)\n    }, outputParser);\n  }\n  async extractToolAndInput(text) {\n    try {\n      const response = await this.outputParser.parse(text);\n      return {\n        tool: response.action,\n        input: response.action_input\n      };\n    } catch {\n      throw new Error(`Unable to parse JSON response from chat agent.\\n\\n${text}`);\n    }\n  }\n}","map":{"version":3,"names":["LLMChain","Agent","SystemMessagePromptTemplate","HumanMessagePromptTemplate","ChatPromptTemplate","MessagesPlaceholder","renderTemplate","PREFIX","SUFFIX","FORMAT_INSTRUCTIONS","TEMPLATE_TOOL_RESPONSE","AIChatMessage","HumanChatMessage","BaseOutputParser","ChatConversationalAgentOutputParser","parse","text","jsonOutput","trim","includes","split","trimStart","trimEnd","startsWith","slice","endsWith","response","JSON","action","action_input","getFormatInstructions","ChatConversationalAgent","constructor","input","outputParser","Object","defineProperty","enumerable","configurable","writable","value","_agentType","Error","observationPrefix","llmPrefix","_stop","validateTools","tools","invalidTool","find","tool","description","msg","name","constructScratchPad","steps","thoughts","step","push","log","observation","createPrompt","args","systemMessage","humanMessage","toolStrings","map","join","formatInstructions","format_instructions","toolNames","finalPrompt","tool_names","messages","fromTemplate","fromPromptMessages","fromLLMAndTools","llm","prompt","chain","llmChain","allowedTools","t","extractToolAndInput"],"sources":["/Users/b/Code/langchainjs/test-exports-cra/node_modules/langchain/dist/agents/chat_convo/index.js"],"sourcesContent":["import { LLMChain } from \"../../chains/llm_chain.js\";\nimport { Agent } from \"../agent.js\";\nimport { SystemMessagePromptTemplate, HumanMessagePromptTemplate, ChatPromptTemplate, MessagesPlaceholder, } from \"../../prompts/chat.js\";\nimport { renderTemplate } from \"../../prompts/template.js\";\nimport { PREFIX, SUFFIX, FORMAT_INSTRUCTIONS, TEMPLATE_TOOL_RESPONSE, } from \"./prompt.js\";\nimport { AIChatMessage, HumanChatMessage, BaseOutputParser, } from \"../../schema/index.js\";\nexport class ChatConversationalAgentOutputParser extends BaseOutputParser {\n    async parse(text) {\n        let jsonOutput = text.trim();\n        if (jsonOutput.includes(\"```json\")) {\n            jsonOutput = jsonOutput.split(\"```json\")[1].trimStart();\n        }\n        if (jsonOutput.includes(\"```\")) {\n            jsonOutput = jsonOutput.split(\"```\")[0].trimEnd();\n        }\n        if (jsonOutput.startsWith(\"```\")) {\n            jsonOutput = jsonOutput.slice(3).trimStart();\n        }\n        if (jsonOutput.endsWith(\"```\")) {\n            jsonOutput = jsonOutput.slice(0, -3).trimEnd();\n        }\n        const response = JSON.parse(jsonOutput);\n        return { action: response.action, action_input: response.action_input };\n    }\n    getFormatInstructions() {\n        return FORMAT_INSTRUCTIONS;\n    }\n}\n/**\n * Agent for the MRKL chain.\n * @augments Agent\n */\nexport class ChatConversationalAgent extends Agent {\n    constructor(input, outputParser) {\n        super(input);\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.outputParser =\n            outputParser ?? new ChatConversationalAgentOutputParser();\n    }\n    _agentType() {\n        /** Not turning on serialization until more sure of abstractions. */\n        throw new Error(\"Method not implemented.\");\n    }\n    observationPrefix() {\n        return \"Observation: \";\n    }\n    llmPrefix() {\n        return \"Thought:\";\n    }\n    _stop() {\n        return [\"Observation:\"];\n    }\n    static validateTools(tools) {\n        const invalidTool = tools.find((tool) => !tool.description);\n        if (invalidTool) {\n            const msg = `Got a tool ${invalidTool.name} without a description.` +\n                ` This agent requires descriptions for all tools.`;\n            throw new Error(msg);\n        }\n    }\n    constructScratchPad(steps) {\n        const thoughts = [];\n        for (const step of steps) {\n            thoughts.push(new AIChatMessage(step.action.log));\n            thoughts.push(new HumanChatMessage(renderTemplate(TEMPLATE_TOOL_RESPONSE, \"f-string\", {\n                observation: step.observation,\n            })));\n        }\n        return thoughts;\n    }\n    /**\n     * Create prompt in the style of the zero shot agent.\n     *\n     * @param tools - List of tools the agent will have access to, used to format the prompt.\n     * @param args - Arguments to create the prompt with.\n     * @param args.suffix - String to put after the list of tools.\n     * @param args.prefix - String to put before the list of tools.\n     */\n    static createPrompt(tools, args) {\n        const { systemMessage = PREFIX, humanMessage = SUFFIX, outputParser = new ChatConversationalAgentOutputParser(), } = args ?? {};\n        const toolStrings = tools\n            .map((tool) => `${tool.name}: ${tool.description}`)\n            .join(\"\\n\");\n        const formatInstructions = renderTemplate(humanMessage, \"f-string\", {\n            format_instructions: outputParser.getFormatInstructions(),\n        });\n        const toolNames = tools.map((tool) => tool.name).join(\"\\n\");\n        const finalPrompt = renderTemplate(formatInstructions, \"f-string\", {\n            tools: toolStrings,\n            tool_names: toolNames,\n        });\n        const messages = [\n            SystemMessagePromptTemplate.fromTemplate(systemMessage),\n            new MessagesPlaceholder(\"chat_history\"),\n            HumanMessagePromptTemplate.fromTemplate(finalPrompt),\n            new MessagesPlaceholder(\"agent_scratchpad\"),\n        ];\n        return ChatPromptTemplate.fromPromptMessages(messages);\n    }\n    static fromLLMAndTools(llm, tools, args) {\n        ChatConversationalAgent.validateTools(tools);\n        const prompt = ChatConversationalAgent.createPrompt(tools, args);\n        const chain = new LLMChain({ prompt, llm });\n        const { outputParser = new ChatConversationalAgentOutputParser() } = args ?? {};\n        return new ChatConversationalAgent({\n            llmChain: chain,\n            allowedTools: tools.map((t) => t.name),\n        }, outputParser);\n    }\n    async extractToolAndInput(text) {\n        try {\n            const response = (await this.outputParser.parse(text));\n            return { tool: response.action, input: response.action_input };\n        }\n        catch {\n            throw new Error(`Unable to parse JSON response from chat agent.\\n\\n${text}`);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}