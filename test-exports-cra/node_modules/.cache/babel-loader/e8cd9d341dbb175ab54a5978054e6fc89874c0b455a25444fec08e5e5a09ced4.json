{"ast":null,"code":"class ParseError extends Error {\n  constructor(msg, output) {\n    super(msg);\n    Object.defineProperty(this, \"output\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.output = output;\n  }\n}\nexport class BaseAgent {\n  get returnValues() {\n    return [\"output\"];\n  }\n  get allowedTools() {\n    return undefined;\n  }\n  /**\n   * Return the string type key uniquely identifying this class of agent.\n   */\n  _agentType() {\n    throw new Error(\"Not implemented\");\n  }\n  /**\n   * Return response when agent has been stopped due to max iterations\n   */\n  returnStoppedResponse(earlyStoppingMethod, _steps, _inputs) {\n    if (earlyStoppingMethod === \"force\") {\n      return Promise.resolve({\n        returnValues: {\n          output: \"Agent stopped due to max iterations.\"\n        },\n        log: \"\"\n      });\n    }\n    throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n  }\n  /**\n   * Prepare the agent for output, if needed\n   */\n  async prepareForOutput(_returnValues, _steps) {\n    return {};\n  }\n}\nexport class BaseSingleActionAgent extends BaseAgent {}\nexport class BaseMultiActionAgent extends BaseAgent {}\nexport class LLMSingleActionAgent extends BaseSingleActionAgent {\n  constructor(input) {\n    super();\n    Object.defineProperty(this, \"llmChain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"stop\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.stop = input.stop;\n    this.llmChain = input.llmChain;\n    this.outputParser = input.outputParser;\n  }\n  get inputKeys() {\n    return this.llmChain.inputKeys;\n  }\n  /**\n   * Decide what to do given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  async plan(steps, inputs) {\n    const output = await this.llmChain.call({\n      intermediate_steps: steps,\n      stop: this.stop,\n      ...inputs\n    });\n    return this.outputParser.parse(output[this.llmChain.outputKey]);\n  }\n}\n/**\n * Class responsible for calling a language model and deciding an action.\n *\n * @remarks This is driven by an LLMChain. The prompt in the LLMChain *must*\n * include a variable called \"agent_scratchpad\" where the agent can put its\n * intermediary work.\n */\nexport class Agent extends BaseSingleActionAgent {\n  get allowedTools() {\n    return this._allowedTools;\n  }\n  get inputKeys() {\n    return this.llmChain.inputKeys.filter(k => k !== \"agent_scratchpad\");\n  }\n  constructor(input) {\n    super();\n    Object.defineProperty(this, \"llmChain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_allowedTools\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: undefined\n    });\n    this.llmChain = input.llmChain;\n    this._allowedTools = input.allowedTools;\n  }\n  /**\n   * Extract tool and tool input from LLM output.\n   */\n  async extractToolAndInput(_input) {\n    throw new Error(\"Not implemented\");\n  }\n  /**\n   * Create a prompt for this class\n   *\n   * @param _tools - List of tools the agent will have access to, used to format the prompt.\n   * @param _fields - Additional fields used to format the prompt.\n   *\n   * @returns A PromptTemplate assembled from the given tools and fields.\n   * */\n  static createPrompt(_tools,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _fields) {\n    throw new Error(\"Not implemented\");\n  }\n  /** Construct an agent from an LLM and a list of tools */\n  static fromLLMAndTools(_llm, _tools,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _args) {\n    throw new Error(\"Not implemented\");\n  }\n  /**\n   * Validate that appropriate tools are passed in\n   */\n  static validateTools(_tools) {}\n  _stop() {\n    return [`\\n${this.observationPrefix()}`];\n  }\n  /**\n   * Name of tool to use to terminate the chain.\n   */\n  finishToolName() {\n    return \"Final Answer\";\n  }\n  /**\n   * Construct a scratchpad to let the agent continue its thought process\n   */\n  constructScratchPad(steps) {\n    return steps.reduce((thoughts, _ref) => {\n      let {\n        action,\n        observation\n      } = _ref;\n      return thoughts + [action.log, `${this.observationPrefix()}${observation}`, this.llmPrefix()].join(\"\\n\");\n    }, \"\");\n  }\n  async _plan(steps, inputs, suffix) {\n    const thoughts = this.constructScratchPad(steps);\n    const newInputs = {\n      ...inputs,\n      agent_scratchpad: suffix ? `${thoughts}${suffix}` : thoughts\n    };\n    if (this._stop().length !== 0) {\n      newInputs.stop = this._stop();\n    }\n    const output = await this.llmChain.predict(newInputs);\n    const parsed = await this.extractToolAndInput(output);\n    if (!parsed) {\n      throw new ParseError(`Invalid output: ${output}`, output);\n    }\n    const action = {\n      tool: parsed.tool,\n      toolInput: parsed.input,\n      log: output\n    };\n    if (action.tool === this.finishToolName()) {\n      return {\n        returnValues: {\n          output: action.toolInput\n        },\n        log: action.log\n      };\n    }\n    return action;\n  }\n  /**\n   * Decide what to do given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  plan(steps, inputs) {\n    return this._plan(steps, inputs);\n  }\n  /**\n   * Return response when agent has been stopped due to max iterations\n   */\n  async returnStoppedResponse(earlyStoppingMethod, steps, inputs) {\n    if (earlyStoppingMethod === \"force\") {\n      return {\n        returnValues: {\n          output: \"Agent stopped due to max iterations.\"\n        },\n        log: \"\"\n      };\n    }\n    if (earlyStoppingMethod === \"generate\") {\n      try {\n        const action = await this._plan(steps, inputs, \"\\n\\nI now need to return a final answer based on the previous steps:\");\n        if (\"returnValues\" in action) {\n          return action;\n        }\n        return {\n          returnValues: {\n            output: action.log\n          },\n          log: action.log\n        };\n      } catch (err) {\n        // fine to use instanceof because we're in the same module\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!(err instanceof ParseError)) {\n          throw err;\n        }\n        return {\n          returnValues: {\n            output: err.output\n          },\n          log: err.output\n        };\n      }\n    }\n    throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n  }\n  /**\n   * Load an agent from a json-like object describing it.\n   */\n  static async deserialize(data) {\n    switch (data._type) {\n      case \"zero-shot-react-description\":\n        {\n          const {\n            ZeroShotAgent\n          } = await import(\"./mrkl/index.js\");\n          return ZeroShotAgent.deserialize(data);\n        }\n      default:\n        throw new Error(\"Unknown agent type\");\n    }\n  }\n}","map":{"version":3,"names":["ParseError","Error","constructor","msg","output","Object","defineProperty","enumerable","configurable","writable","value","BaseAgent","returnValues","allowedTools","undefined","_agentType","returnStoppedResponse","earlyStoppingMethod","_steps","_inputs","Promise","resolve","log","prepareForOutput","_returnValues","BaseSingleActionAgent","BaseMultiActionAgent","LLMSingleActionAgent","input","stop","llmChain","outputParser","inputKeys","plan","steps","inputs","call","intermediate_steps","parse","outputKey","Agent","_allowedTools","filter","k","extractToolAndInput","_input","createPrompt","_tools","_fields","fromLLMAndTools","_llm","_args","validateTools","_stop","observationPrefix","finishToolName","constructScratchPad","reduce","thoughts","_ref","action","observation","llmPrefix","join","_plan","suffix","newInputs","agent_scratchpad","length","predict","parsed","tool","toolInput","err","deserialize","data","_type","ZeroShotAgent"],"sources":["/Users/b/Code/langchainjs/langchain/dist/agents/agent.js"],"sourcesContent":["class ParseError extends Error {\n    constructor(msg, output) {\n        super(msg);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\nexport class BaseAgent {\n    get returnValues() {\n        return [\"output\"];\n    }\n    get allowedTools() {\n        return undefined;\n    }\n    /**\n     * Return the string type key uniquely identifying this class of agent.\n     */\n    _agentType() {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Return response when agent has been stopped due to max iterations\n     */\n    returnStoppedResponse(earlyStoppingMethod, _steps, _inputs) {\n        if (earlyStoppingMethod === \"force\") {\n            return Promise.resolve({\n                returnValues: { output: \"Agent stopped due to max iterations.\" },\n                log: \"\",\n            });\n        }\n        throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n    }\n    /**\n     * Prepare the agent for output, if needed\n     */\n    async prepareForOutput(_returnValues, _steps) {\n        return {};\n    }\n}\nexport class BaseSingleActionAgent extends BaseAgent {\n}\nexport class BaseMultiActionAgent extends BaseAgent {\n}\nexport class LLMSingleActionAgent extends BaseSingleActionAgent {\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stop\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.stop = input.stop;\n        this.llmChain = input.llmChain;\n        this.outputParser = input.outputParser;\n    }\n    get inputKeys() {\n        return this.llmChain.inputKeys;\n    }\n    /**\n     * Decide what to do given some input.\n     *\n     * @param steps - Steps the LLM has taken so far, along with observations from each.\n     * @param inputs - User inputs.\n     *\n     * @returns Action specifying what tool to use.\n     */\n    async plan(steps, inputs) {\n        const output = await this.llmChain.call({\n            intermediate_steps: steps,\n            stop: this.stop,\n            ...inputs,\n        });\n        return this.outputParser.parse(output[this.llmChain.outputKey]);\n    }\n}\n/**\n * Class responsible for calling a language model and deciding an action.\n *\n * @remarks This is driven by an LLMChain. The prompt in the LLMChain *must*\n * include a variable called \"agent_scratchpad\" where the agent can put its\n * intermediary work.\n */\nexport class Agent extends BaseSingleActionAgent {\n    get allowedTools() {\n        return this._allowedTools;\n    }\n    get inputKeys() {\n        return this.llmChain.inputKeys.filter((k) => k !== \"agent_scratchpad\");\n    }\n    constructor(input) {\n        super();\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_allowedTools\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        this.llmChain = input.llmChain;\n        this._allowedTools = input.allowedTools;\n    }\n    /**\n     * Extract tool and tool input from LLM output.\n     */\n    async extractToolAndInput(_input) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Create a prompt for this class\n     *\n     * @param _tools - List of tools the agent will have access to, used to format the prompt.\n     * @param _fields - Additional fields used to format the prompt.\n     *\n     * @returns A PromptTemplate assembled from the given tools and fields.\n     * */\n    static createPrompt(_tools, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _fields) {\n        throw new Error(\"Not implemented\");\n    }\n    /** Construct an agent from an LLM and a list of tools */\n    static fromLLMAndTools(_llm, _tools, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _args) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Validate that appropriate tools are passed in\n     */\n    static validateTools(_tools) { }\n    _stop() {\n        return [`\\n${this.observationPrefix()}`];\n    }\n    /**\n     * Name of tool to use to terminate the chain.\n     */\n    finishToolName() {\n        return \"Final Answer\";\n    }\n    /**\n     * Construct a scratchpad to let the agent continue its thought process\n     */\n    constructScratchPad(steps) {\n        return steps.reduce((thoughts, { action, observation }) => thoughts +\n            [\n                action.log,\n                `${this.observationPrefix()}${observation}`,\n                this.llmPrefix(),\n            ].join(\"\\n\"), \"\");\n    }\n    async _plan(steps, inputs, suffix) {\n        const thoughts = this.constructScratchPad(steps);\n        const newInputs = {\n            ...inputs,\n            agent_scratchpad: suffix ? `${thoughts}${suffix}` : thoughts,\n        };\n        if (this._stop().length !== 0) {\n            newInputs.stop = this._stop();\n        }\n        const output = await this.llmChain.predict(newInputs);\n        const parsed = await this.extractToolAndInput(output);\n        if (!parsed) {\n            throw new ParseError(`Invalid output: ${output}`, output);\n        }\n        const action = {\n            tool: parsed.tool,\n            toolInput: parsed.input,\n            log: output,\n        };\n        if (action.tool === this.finishToolName()) {\n            return { returnValues: { output: action.toolInput }, log: action.log };\n        }\n        return action;\n    }\n    /**\n     * Decide what to do given some input.\n     *\n     * @param steps - Steps the LLM has taken so far, along with observations from each.\n     * @param inputs - User inputs.\n     *\n     * @returns Action specifying what tool to use.\n     */\n    plan(steps, inputs) {\n        return this._plan(steps, inputs);\n    }\n    /**\n     * Return response when agent has been stopped due to max iterations\n     */\n    async returnStoppedResponse(earlyStoppingMethod, steps, inputs) {\n        if (earlyStoppingMethod === \"force\") {\n            return {\n                returnValues: { output: \"Agent stopped due to max iterations.\" },\n                log: \"\",\n            };\n        }\n        if (earlyStoppingMethod === \"generate\") {\n            try {\n                const action = await this._plan(steps, inputs, \"\\n\\nI now need to return a final answer based on the previous steps:\");\n                if (\"returnValues\" in action) {\n                    return action;\n                }\n                return { returnValues: { output: action.log }, log: action.log };\n            }\n            catch (err) {\n                // fine to use instanceof because we're in the same module\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                if (!(err instanceof ParseError)) {\n                    throw err;\n                }\n                return { returnValues: { output: err.output }, log: err.output };\n            }\n        }\n        throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n    }\n    /**\n     * Load an agent from a json-like object describing it.\n     */\n    static async deserialize(data) {\n        switch (data._type) {\n            case \"zero-shot-react-description\": {\n                const { ZeroShotAgent } = await import(\"./mrkl/index.js\");\n                return ZeroShotAgent.deserialize(data);\n            }\n            default:\n                throw new Error(\"Unknown agent type\");\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}