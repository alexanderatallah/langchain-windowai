{"ast":null,"code":"import { BaseChain } from \"../chains/base.js\";\nimport { BaseMultiActionAgent } from \"./agent.js\";\n/**\n * A chain managing an agent using tools.\n * @augments BaseChain\n */\nexport class AgentExecutor extends BaseChain {\n  get inputKeys() {\n    return this.agent.inputKeys;\n  }\n  constructor(input) {\n    super(input.memory, input.verbose, input.callbackManager);\n    Object.defineProperty(this, \"agent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tools\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"returnIntermediateSteps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"maxIterations\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 15\n    });\n    Object.defineProperty(this, \"earlyStoppingMethod\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"force\"\n    });\n    this.agent = input.agent;\n    this.tools = input.tools;\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (this.agent instanceof BaseMultiActionAgent) {\n      for (const tool of this.tools) {\n        if (tool.returnDirect) {\n          throw new Error(`Tool with return direct ${tool.name} not supported for multi-action agent.`);\n        }\n      }\n    }\n    this.returnIntermediateSteps = input.returnIntermediateSteps ?? this.returnIntermediateSteps;\n    this.maxIterations = input.maxIterations ?? this.maxIterations;\n    this.earlyStoppingMethod = input.earlyStoppingMethod ?? this.earlyStoppingMethod;\n  }\n  /** Create from agent and a list of tools. */\n  static fromAgentAndTools(fields) {\n    return new AgentExecutor(fields);\n  }\n  shouldContinue(iterations) {\n    return this.maxIterations === undefined || iterations < this.maxIterations;\n  }\n  async _call(inputs) {\n    const toolsByName = Object.fromEntries(this.tools.map(t => [t.name.toLowerCase(), t]));\n    const steps = [];\n    let iterations = 0;\n    const getOutput = async finishStep => {\n      const {\n        returnValues\n      } = finishStep;\n      const additional = await this.agent.prepareForOutput(returnValues, steps);\n      if (this.returnIntermediateSteps) {\n        return {\n          ...returnValues,\n          intermediateSteps: steps,\n          ...additional\n        };\n      }\n      await this.callbackManager.handleAgentEnd(finishStep, this.verbose);\n      return {\n        ...returnValues,\n        ...additional\n      };\n    };\n    while (this.shouldContinue(iterations)) {\n      const output = await this.agent.plan(steps, inputs);\n      // Check if the agent has finished\n      if (\"returnValues\" in output) {\n        return getOutput(output);\n      }\n      let actions;\n      if (Array.isArray(output)) {\n        actions = output;\n      } else {\n        actions = [output];\n      }\n      const newSteps = await Promise.all(actions.map(async action => {\n        await this.callbackManager.handleAgentAction(action, this.verbose);\n        const tool = toolsByName[action.tool?.toLowerCase()];\n        const observation = tool ? await tool.call(action.toolInput, this.verbose) : `${action.tool} is not a valid tool, try another one.`;\n        return {\n          action,\n          observation\n        };\n      }));\n      steps.push(...newSteps);\n      const lastStep = steps[steps.length - 1];\n      const lastTool = toolsByName[lastStep.action.tool?.toLowerCase()];\n      if (lastTool?.returnDirect) {\n        return getOutput({\n          returnValues: {\n            [this.agent.returnValues[0]]: lastStep.observation\n          },\n          log: \"\"\n        });\n      }\n      iterations += 1;\n    }\n    const finish = await this.agent.returnStoppedResponse(this.earlyStoppingMethod, steps, inputs);\n    return getOutput(finish);\n  }\n  _chainType() {\n    return \"agent_executor\";\n  }\n  serialize() {\n    throw new Error(\"Cannot serialize an AgentExecutor\");\n  }\n}","map":{"version":3,"names":["BaseChain","BaseMultiActionAgent","AgentExecutor","inputKeys","agent","constructor","input","memory","verbose","callbackManager","Object","defineProperty","enumerable","configurable","writable","value","tools","tool","returnDirect","Error","name","returnIntermediateSteps","maxIterations","earlyStoppingMethod","fromAgentAndTools","fields","shouldContinue","iterations","undefined","_call","inputs","toolsByName","fromEntries","map","t","toLowerCase","steps","getOutput","finishStep","returnValues","additional","prepareForOutput","intermediateSteps","handleAgentEnd","output","plan","actions","Array","isArray","newSteps","Promise","all","action","handleAgentAction","observation","call","toolInput","push","lastStep","length","lastTool","log","finish","returnStoppedResponse","_chainType","serialize"],"sources":["/Users/b/Code/langchainjs/langchain/dist/agents/executor.js"],"sourcesContent":["import { BaseChain } from \"../chains/base.js\";\nimport { BaseMultiActionAgent } from \"./agent.js\";\n/**\n * A chain managing an agent using tools.\n * @augments BaseChain\n */\nexport class AgentExecutor extends BaseChain {\n    get inputKeys() {\n        return this.agent.inputKeys;\n    }\n    constructor(input) {\n        super(input.memory, input.verbose, input.callbackManager);\n        Object.defineProperty(this, \"agent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tools\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"returnIntermediateSteps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"maxIterations\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 15\n        });\n        Object.defineProperty(this, \"earlyStoppingMethod\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"force\"\n        });\n        this.agent = input.agent;\n        this.tools = input.tools;\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (this.agent instanceof BaseMultiActionAgent) {\n            for (const tool of this.tools) {\n                if (tool.returnDirect) {\n                    throw new Error(`Tool with return direct ${tool.name} not supported for multi-action agent.`);\n                }\n            }\n        }\n        this.returnIntermediateSteps =\n            input.returnIntermediateSteps ?? this.returnIntermediateSteps;\n        this.maxIterations = input.maxIterations ?? this.maxIterations;\n        this.earlyStoppingMethod =\n            input.earlyStoppingMethod ?? this.earlyStoppingMethod;\n    }\n    /** Create from agent and a list of tools. */\n    static fromAgentAndTools(fields) {\n        return new AgentExecutor(fields);\n    }\n    shouldContinue(iterations) {\n        return this.maxIterations === undefined || iterations < this.maxIterations;\n    }\n    async _call(inputs) {\n        const toolsByName = Object.fromEntries(this.tools.map((t) => [t.name.toLowerCase(), t]));\n        const steps = [];\n        let iterations = 0;\n        const getOutput = async (finishStep) => {\n            const { returnValues } = finishStep;\n            const additional = await this.agent.prepareForOutput(returnValues, steps);\n            if (this.returnIntermediateSteps) {\n                return { ...returnValues, intermediateSteps: steps, ...additional };\n            }\n            await this.callbackManager.handleAgentEnd(finishStep, this.verbose);\n            return { ...returnValues, ...additional };\n        };\n        while (this.shouldContinue(iterations)) {\n            const output = await this.agent.plan(steps, inputs);\n            // Check if the agent has finished\n            if (\"returnValues\" in output) {\n                return getOutput(output);\n            }\n            let actions;\n            if (Array.isArray(output)) {\n                actions = output;\n            }\n            else {\n                actions = [output];\n            }\n            const newSteps = await Promise.all(actions.map(async (action) => {\n                await this.callbackManager.handleAgentAction(action, this.verbose);\n                const tool = toolsByName[action.tool?.toLowerCase()];\n                const observation = tool\n                    ? await tool.call(action.toolInput, this.verbose)\n                    : `${action.tool} is not a valid tool, try another one.`;\n                return { action, observation };\n            }));\n            steps.push(...newSteps);\n            const lastStep = steps[steps.length - 1];\n            const lastTool = toolsByName[lastStep.action.tool?.toLowerCase()];\n            if (lastTool?.returnDirect) {\n                return getOutput({\n                    returnValues: { [this.agent.returnValues[0]]: lastStep.observation },\n                    log: \"\",\n                });\n            }\n            iterations += 1;\n        }\n        const finish = await this.agent.returnStoppedResponse(this.earlyStoppingMethod, steps, inputs);\n        return getOutput(finish);\n    }\n    _chainType() {\n        return \"agent_executor\";\n    }\n    serialize() {\n        throw new Error(\"Cannot serialize an AgentExecutor\");\n    }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,oBAAoB,QAAQ,YAAY;AACjD;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,SAASF,SAAS,CAAC;EACzC,IAAIG,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,KAAK,CAACD,SAAS;EAC/B;EACAE,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAACA,KAAK,CAACC,MAAM,EAAED,KAAK,CAACE,OAAO,EAAEF,KAAK,CAACG,eAAe,CAAC;IACzDC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,yBAAyB,EAAE;MACnDC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,eAAe,EAAE;MACzCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,qBAAqB,EAAE;MAC/CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACF,IAAI,CAACX,KAAK,GAAGE,KAAK,CAACF,KAAK;IACxB,IAAI,CAACY,KAAK,GAAGV,KAAK,CAACU,KAAK;IACxB;IACA,IAAI,IAAI,CAACZ,KAAK,YAAYH,oBAAoB,EAAE;MAC5C,KAAK,MAAMgB,IAAI,IAAI,IAAI,CAACD,KAAK,EAAE;QAC3B,IAAIC,IAAI,CAACC,YAAY,EAAE;UACnB,MAAM,IAAIC,KAAK,CAAE,2BAA0BF,IAAI,CAACG,IAAK,wCAAuC,CAAC;QACjG;MACJ;IACJ;IACA,IAAI,CAACC,uBAAuB,GACxBf,KAAK,CAACe,uBAAuB,IAAI,IAAI,CAACA,uBAAuB;IACjE,IAAI,CAACC,aAAa,GAAGhB,KAAK,CAACgB,aAAa,IAAI,IAAI,CAACA,aAAa;IAC9D,IAAI,CAACC,mBAAmB,GACpBjB,KAAK,CAACiB,mBAAmB,IAAI,IAAI,CAACA,mBAAmB;EAC7D;EACA;EACA,OAAOC,iBAAiBA,CAACC,MAAM,EAAE;IAC7B,OAAO,IAAIvB,aAAa,CAACuB,MAAM,CAAC;EACpC;EACAC,cAAcA,CAACC,UAAU,EAAE;IACvB,OAAO,IAAI,CAACL,aAAa,KAAKM,SAAS,IAAID,UAAU,GAAG,IAAI,CAACL,aAAa;EAC9E;EACA,MAAMO,KAAKA,CAACC,MAAM,EAAE;IAChB,MAAMC,WAAW,GAAGrB,MAAM,CAACsB,WAAW,CAAC,IAAI,CAAChB,KAAK,CAACiB,GAAG,CAAEC,CAAC,IAAK,CAACA,CAAC,CAACd,IAAI,CAACe,WAAW,EAAE,EAAED,CAAC,CAAC,CAAC,CAAC;IACxF,MAAME,KAAK,GAAG,EAAE;IAChB,IAAIT,UAAU,GAAG,CAAC;IAClB,MAAMU,SAAS,GAAG,MAAOC,UAAU,IAAK;MACpC,MAAM;QAAEC;MAAa,CAAC,GAAGD,UAAU;MACnC,MAAME,UAAU,GAAG,MAAM,IAAI,CAACpC,KAAK,CAACqC,gBAAgB,CAACF,YAAY,EAAEH,KAAK,CAAC;MACzE,IAAI,IAAI,CAACf,uBAAuB,EAAE;QAC9B,OAAO;UAAE,GAAGkB,YAAY;UAAEG,iBAAiB,EAAEN,KAAK;UAAE,GAAGI;QAAW,CAAC;MACvE;MACA,MAAM,IAAI,CAAC/B,eAAe,CAACkC,cAAc,CAACL,UAAU,EAAE,IAAI,CAAC9B,OAAO,CAAC;MACnE,OAAO;QAAE,GAAG+B,YAAY;QAAE,GAAGC;MAAW,CAAC;IAC7C,CAAC;IACD,OAAO,IAAI,CAACd,cAAc,CAACC,UAAU,CAAC,EAAE;MACpC,MAAMiB,MAAM,GAAG,MAAM,IAAI,CAACxC,KAAK,CAACyC,IAAI,CAACT,KAAK,EAAEN,MAAM,CAAC;MACnD;MACA,IAAI,cAAc,IAAIc,MAAM,EAAE;QAC1B,OAAOP,SAAS,CAACO,MAAM,CAAC;MAC5B;MACA,IAAIE,OAAO;MACX,IAAIC,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,EAAE;QACvBE,OAAO,GAAGF,MAAM;MACpB,CAAC,MACI;QACDE,OAAO,GAAG,CAACF,MAAM,CAAC;MACtB;MACA,MAAMK,QAAQ,GAAG,MAAMC,OAAO,CAACC,GAAG,CAACL,OAAO,CAACb,GAAG,CAAC,MAAOmB,MAAM,IAAK;QAC7D,MAAM,IAAI,CAAC3C,eAAe,CAAC4C,iBAAiB,CAACD,MAAM,EAAE,IAAI,CAAC5C,OAAO,CAAC;QAClE,MAAMS,IAAI,GAAGc,WAAW,CAACqB,MAAM,CAACnC,IAAI,EAAEkB,WAAW,EAAE,CAAC;QACpD,MAAMmB,WAAW,GAAGrC,IAAI,GAClB,MAAMA,IAAI,CAACsC,IAAI,CAACH,MAAM,CAACI,SAAS,EAAE,IAAI,CAAChD,OAAO,CAAC,GAC9C,GAAE4C,MAAM,CAACnC,IAAK,wCAAuC;QAC5D,OAAO;UAAEmC,MAAM;UAAEE;QAAY,CAAC;MAClC,CAAC,CAAC,CAAC;MACHlB,KAAK,CAACqB,IAAI,CAAC,GAAGR,QAAQ,CAAC;MACvB,MAAMS,QAAQ,GAAGtB,KAAK,CAACA,KAAK,CAACuB,MAAM,GAAG,CAAC,CAAC;MACxC,MAAMC,QAAQ,GAAG7B,WAAW,CAAC2B,QAAQ,CAACN,MAAM,CAACnC,IAAI,EAAEkB,WAAW,EAAE,CAAC;MACjE,IAAIyB,QAAQ,EAAE1C,YAAY,EAAE;QACxB,OAAOmB,SAAS,CAAC;UACbE,YAAY,EAAE;YAAE,CAAC,IAAI,CAACnC,KAAK,CAACmC,YAAY,CAAC,CAAC,CAAC,GAAGmB,QAAQ,CAACJ;UAAY,CAAC;UACpEO,GAAG,EAAE;QACT,CAAC,CAAC;MACN;MACAlC,UAAU,IAAI,CAAC;IACnB;IACA,MAAMmC,MAAM,GAAG,MAAM,IAAI,CAAC1D,KAAK,CAAC2D,qBAAqB,CAAC,IAAI,CAACxC,mBAAmB,EAAEa,KAAK,EAAEN,MAAM,CAAC;IAC9F,OAAOO,SAAS,CAACyB,MAAM,CAAC;EAC5B;EACAE,UAAUA,CAAA,EAAG;IACT,OAAO,gBAAgB;EAC3B;EACAC,SAASA,CAAA,EAAG;IACR,MAAM,IAAI9C,KAAK,CAAC,mCAAmC,CAAC;EACxD;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}