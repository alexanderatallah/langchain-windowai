{"ast":null,"code":"import { BaseChain } from \"./base.js\";\nimport { RecursiveCharacterTextSplitter } from \"../text_splitter.js\";\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class AnalyzeDocumentChain extends BaseChain {\n  constructor(fields) {\n    super();\n    Object.defineProperty(this, \"inputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"input_document\"\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"output_text\"\n    });\n    Object.defineProperty(this, \"combineDocumentsChain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textSplitter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.combineDocumentsChain = fields.combineDocumentsChain;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.outputKey = fields.outputKey ?? this.outputKey;\n    this.textSplitter = fields.textSplitter ?? new RecursiveCharacterTextSplitter();\n  }\n  get inputKeys() {\n    return [this.inputKey];\n  }\n  async _call(values) {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const {\n      [this.inputKey]: doc,\n      ...rest\n    } = values;\n    const currentDoc = doc;\n    const currentDocs = await this.textSplitter.createDocuments([currentDoc]);\n    const newInputs = {\n      input_documents: currentDocs,\n      ...rest\n    };\n    const result = await this.combineDocumentsChain.call(newInputs);\n    return result;\n  }\n  _chainType() {\n    return \"analyze_document_chain\";\n  }\n  static async deserialize(data, values) {\n    if (!(\"text_splitter\" in values)) {\n      throw new Error(`Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.`);\n    }\n    const {\n      text_splitter\n    } = values;\n    if (!data.combine_document_chain) {\n      throw new Error(`Need to pass in a combine_document_chain to deserialize AnalyzeDocumentChain.`);\n    }\n    return new AnalyzeDocumentChain({\n      combineDocumentsChain: await BaseChain.deserialize(data.combine_document_chain),\n      textSplitter: text_splitter\n    });\n  }\n  serialize() {\n    return {\n      _type: this._chainType(),\n      combine_document_chain: this.combineDocumentsChain.serialize()\n    };\n  }\n}","map":{"version":3,"names":["BaseChain","RecursiveCharacterTextSplitter","AnalyzeDocumentChain","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","combineDocumentsChain","inputKey","outputKey","textSplitter","inputKeys","_call","values","Error","doc","rest","currentDoc","currentDocs","createDocuments","newInputs","input_documents","result","call","_chainType","deserialize","data","text_splitter","combine_document_chain","serialize","_type"],"sources":["/Users/b/Code/langchainjs/test-exports-cra/node_modules/langchain/dist/chains/analyze_documents_chain.js"],"sourcesContent":["import { BaseChain } from \"./base.js\";\nimport { RecursiveCharacterTextSplitter, } from \"../text_splitter.js\";\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class AnalyzeDocumentChain extends BaseChain {\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input_document\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output_text\"\n        });\n        Object.defineProperty(this, \"combineDocumentsChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"textSplitter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.combineDocumentsChain = fields.combineDocumentsChain;\n        this.inputKey = fields.inputKey ?? this.inputKey;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n        this.textSplitter =\n            fields.textSplitter ?? new RecursiveCharacterTextSplitter();\n    }\n    get inputKeys() {\n        return [this.inputKey];\n    }\n    async _call(values) {\n        if (!(this.inputKey in values)) {\n            throw new Error(`Document key ${this.inputKey} not found.`);\n        }\n        const { [this.inputKey]: doc, ...rest } = values;\n        const currentDoc = doc;\n        const currentDocs = await this.textSplitter.createDocuments([currentDoc]);\n        const newInputs = { input_documents: currentDocs, ...rest };\n        const result = await this.combineDocumentsChain.call(newInputs);\n        return result;\n    }\n    _chainType() {\n        return \"analyze_document_chain\";\n    }\n    static async deserialize(data, values) {\n        if (!(\"text_splitter\" in values)) {\n            throw new Error(`Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.`);\n        }\n        const { text_splitter } = values;\n        if (!data.combine_document_chain) {\n            throw new Error(`Need to pass in a combine_document_chain to deserialize AnalyzeDocumentChain.`);\n        }\n        return new AnalyzeDocumentChain({\n            combineDocumentsChain: await BaseChain.deserialize(data.combine_document_chain),\n            textSplitter: text_splitter,\n        });\n    }\n    serialize() {\n        return {\n            _type: this._chainType(),\n            combine_document_chain: this.combineDocumentsChain.serialize(),\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}