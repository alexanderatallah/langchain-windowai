{"ast":null,"code":"import { BaseStringPromptTemplate } from \"./base.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n  constructor(input) {\n    super(input);\n    Object.defineProperty(this, \"template\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"templateFormat\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"f-string\"\n    });\n    Object.defineProperty(this, \"validateTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.assign(this, input);\n    if (this.validateTemplate) {\n      let totalInputVariables = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n      }\n      checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n    }\n  }\n  _getPromptType() {\n    return \"prompt\";\n  }\n  async format(values) {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    return renderTemplate(this.template, this.templateFormat, allValues);\n  }\n  /**\n   * Take examples in list format with prefix and suffix to create a prompt.\n   *\n   * Intendend to be used a a way to dynamically create a prompt from examples.\n   *\n   * @param examples - List of examples to use in the prompt.\n   * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n   * @param inputVariables - A list of variable names the final prompt template will expect\n   * @param exampleSeparator - The separator to use in between examples\n   * @param prefix - String that should go before any examples. Generally includes examples.\n   *\n   * @returns The final prompt template generated.\n   */\n  static fromExamples(examples, suffix, inputVariables) {\n    let exampleSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\\n\\n\";\n    let prefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    const template = [prefix, ...examples, suffix].join(exampleSeparator);\n    return new PromptTemplate({\n      inputVariables,\n      template\n    });\n  }\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate(template) {\n    let {\n      templateFormat = \"f-string\",\n      ...rest\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const names = new Set();\n    parseTemplate(template, templateFormat).forEach(node => {\n      if (node.type === \"variable\") {\n        names.add(node.name);\n      }\n    });\n    return new PromptTemplate({\n      inputVariables: [...names],\n      templateFormat,\n      template,\n      ...rest\n    });\n  }\n  async partial(values) {\n    const promptDict = {\n      ...this\n    };\n    promptDict.inputVariables = this.inputVariables.filter(iv => !(iv in values));\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values\n    };\n    return new PromptTemplate(promptDict);\n  }\n  serialize() {\n    if (this.outputParser !== undefined) {\n      throw new Error(\"Cannot serialize a prompt template with an output parser\");\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      template: this.template,\n      template_format: this.templateFormat\n    };\n  }\n  static async deserialize(data) {\n    if (!data.template) {\n      throw new Error(\"Prompt template must have a template\");\n    }\n    const res = new PromptTemplate({\n      inputVariables: data.input_variables,\n      template: data.template,\n      templateFormat: data.template_format\n    });\n    return res;\n  }\n}","map":{"version":3,"names":["BaseStringPromptTemplate","checkValidTemplate","parseTemplate","renderTemplate","PromptTemplate","constructor","input","Object","defineProperty","enumerable","configurable","writable","value","assign","validateTemplate","totalInputVariables","inputVariables","partialVariables","concat","keys","template","templateFormat","_getPromptType","format","values","allValues","mergePartialAndUserVariables","fromExamples","examples","suffix","exampleSeparator","arguments","length","undefined","prefix","join","fromTemplate","rest","names","Set","forEach","node","type","add","name","partial","promptDict","filter","iv","serialize","outputParser","Error","_type","input_variables","template_format","deserialize","data","res"],"sources":["/Users/b/Code/langchainjs/test-exports-cra/node_modules/langchain/dist/prompts/prompt.js"],"sourcesContent":["import { BaseStringPromptTemplate } from \"./base.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intendend to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    /**\n     * Load prompt template from a template f-string\n     */\n    static fromTemplate(template, { templateFormat = \"f-string\", ...rest } = {}) {\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    async partial(values) {\n        const promptDict = { ...this };\n        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        promptDict.partialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n"],"mappings":"AAAA,SAASA,wBAAwB,QAAQ,WAAW;AACpD,SAASC,kBAAkB,EAAEC,aAAa,EAAEC,cAAc,QAAS,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,SAASJ,wBAAwB,CAAC;EACzDK,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAACA,KAAK,CAAC;IACZC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACpCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,gBAAgB,EAAE;MAC1CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAC5CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACM,MAAM,CAAC,IAAI,EAAEP,KAAK,CAAC;IAC1B,IAAI,IAAI,CAACQ,gBAAgB,EAAE;MACvB,IAAIC,mBAAmB,GAAG,IAAI,CAACC,cAAc;MAC7C,IAAI,IAAI,CAACC,gBAAgB,EAAE;QACvBF,mBAAmB,GAAGA,mBAAmB,CAACG,MAAM,CAACX,MAAM,CAACY,IAAI,CAAC,IAAI,CAACF,gBAAgB,CAAC,CAAC;MACxF;MACAhB,kBAAkB,CAAC,IAAI,CAACmB,QAAQ,EAAE,IAAI,CAACC,cAAc,EAAEN,mBAAmB,CAAC;IAC/E;EACJ;EACAO,cAAcA,CAAA,EAAG;IACb,OAAO,QAAQ;EACnB;EACA,MAAMC,MAAMA,CAACC,MAAM,EAAE;IACjB,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACC,4BAA4B,CAACF,MAAM,CAAC;IACjE,OAAOrB,cAAc,CAAC,IAAI,CAACiB,QAAQ,EAAE,IAAI,CAACC,cAAc,EAAEI,SAAS,CAAC;EACxE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOE,YAAYA,CAACC,QAAQ,EAAEC,MAAM,EAAEb,cAAc,EAA0C;IAAA,IAAxCc,gBAAgB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,MAAM;IAAA,IAAEG,MAAM,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IACxF,MAAMX,QAAQ,GAAG,CAACc,MAAM,EAAE,GAAGN,QAAQ,EAAEC,MAAM,CAAC,CAACM,IAAI,CAACL,gBAAgB,CAAC;IACrE,OAAO,IAAI1B,cAAc,CAAC;MACtBY,cAAc;MACdI;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACI,OAAOgB,YAAYA,CAAChB,QAAQ,EAAiD;IAAA,IAA/C;MAAEC,cAAc,GAAG,UAAU;MAAE,GAAGgB;IAAK,CAAC,GAAAN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACvE,MAAMO,KAAK,GAAG,IAAIC,GAAG,EAAE;IACvBrC,aAAa,CAACkB,QAAQ,EAAEC,cAAc,CAAC,CAACmB,OAAO,CAAEC,IAAI,IAAK;MACtD,IAAIA,IAAI,CAACC,IAAI,KAAK,UAAU,EAAE;QAC1BJ,KAAK,CAACK,GAAG,CAACF,IAAI,CAACG,IAAI,CAAC;MACxB;IACJ,CAAC,CAAC;IACF,OAAO,IAAIxC,cAAc,CAAC;MACtBY,cAAc,EAAE,CAAC,GAAGsB,KAAK,CAAC;MAC1BjB,cAAc;MACdD,QAAQ;MACR,GAAGiB;IACP,CAAC,CAAC;EACN;EACA,MAAMQ,OAAOA,CAACrB,MAAM,EAAE;IAClB,MAAMsB,UAAU,GAAG;MAAE,GAAG;IAAK,CAAC;IAC9BA,UAAU,CAAC9B,cAAc,GAAG,IAAI,CAACA,cAAc,CAAC+B,MAAM,CAAEC,EAAE,IAAK,EAAEA,EAAE,IAAIxB,MAAM,CAAC,CAAC;IAC/EsB,UAAU,CAAC7B,gBAAgB,GAAG;MAC1B,IAAI,IAAI,CAACA,gBAAgB,IAAI,CAAC,CAAC,CAAC;MAChC,GAAGO;IACP,CAAC;IACD,OAAO,IAAIpB,cAAc,CAAC0C,UAAU,CAAC;EACzC;EACAG,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAACC,YAAY,KAAKjB,SAAS,EAAE;MACjC,MAAM,IAAIkB,KAAK,CAAC,0DAA0D,CAAC;IAC/E;IACA,OAAO;MACHC,KAAK,EAAE,IAAI,CAAC9B,cAAc,EAAE;MAC5B+B,eAAe,EAAE,IAAI,CAACrC,cAAc;MACpCI,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBkC,eAAe,EAAE,IAAI,CAACjC;IAC1B,CAAC;EACL;EACA,aAAakC,WAAWA,CAACC,IAAI,EAAE;IAC3B,IAAI,CAACA,IAAI,CAACpC,QAAQ,EAAE;MAChB,MAAM,IAAI+B,KAAK,CAAC,sCAAsC,CAAC;IAC3D;IACA,MAAMM,GAAG,GAAG,IAAIrD,cAAc,CAAC;MAC3BY,cAAc,EAAEwC,IAAI,CAACH,eAAe;MACpCjC,QAAQ,EAAEoC,IAAI,CAACpC,QAAQ;MACvBC,cAAc,EAAEmC,IAAI,CAACF;IACzB,CAAC,CAAC;IACF,OAAOG,GAAG;EACd;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}