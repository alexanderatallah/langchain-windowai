{"ast":null,"code":"import { BaseChain } from \"./base.js\";\nimport { LLMChain } from \"./llm_chain.js\";\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class StuffDocumentsChain extends BaseChain {\n  get inputKeys() {\n    return [this.inputKey, ...this.llmChain.inputKeys];\n  }\n  constructor(fields) {\n    super();\n    Object.defineProperty(this, \"llmChain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"input_documents\"\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"output_text\"\n    });\n    Object.defineProperty(this, \"documentVariableName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"context\"\n    });\n    this.llmChain = fields.llmChain;\n    this.documentVariableName = fields.documentVariableName ?? this.documentVariableName;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.outputKey = fields.outputKey ?? this.outputKey;\n  }\n  async _call(values) {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const {\n      [this.inputKey]: docs,\n      ...rest\n    } = values;\n    const texts = docs.map(_ref => {\n      let {\n        pageContent\n      } = _ref;\n      return pageContent;\n    });\n    const text = texts.join(\"\\n\\n\");\n    const result = await this.llmChain.call({\n      ...rest,\n      [this.documentVariableName]: text\n    });\n    return result;\n  }\n  _chainType() {\n    return \"stuff_documents_chain\";\n  }\n  static async deserialize(data) {\n    if (!data.llm_chain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n    return new StuffDocumentsChain({\n      llmChain: await LLMChain.deserialize(data.llm_chain)\n    });\n  }\n  serialize() {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize()\n    };\n  }\n}\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class MapReduceDocumentsChain extends BaseChain {\n  get inputKeys() {\n    return [this.inputKey, ...this.combineDocumentChain.inputKeys];\n  }\n  constructor(fields) {\n    super();\n    Object.defineProperty(this, \"llmChain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"input_documents\"\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"output_text\"\n    });\n    Object.defineProperty(this, \"documentVariableName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"context\"\n    });\n    Object.defineProperty(this, \"maxTokens\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3000\n    });\n    Object.defineProperty(this, \"maxIterations\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 10\n    });\n    Object.defineProperty(this, \"ensureMapStep\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"combineDocumentChain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.llmChain = fields.llmChain;\n    this.combineDocumentChain = fields.combineDocumentChain;\n    this.documentVariableName = fields.documentVariableName ?? this.documentVariableName;\n    this.ensureMapStep = fields.ensureMapStep ?? this.ensureMapStep;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.outputKey = fields.outputKey ?? this.outputKey;\n    this.maxTokens = fields.maxTokens ?? this.maxTokens;\n    this.maxIterations = fields.maxIterations ?? this.maxIterations;\n  }\n  async _call(values) {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const {\n      [this.inputKey]: docs,\n      ...rest\n    } = values;\n    let currentDocs = docs;\n    for (let i = 0; i < this.maxIterations; i += 1) {\n      const inputs = currentDocs.map(d => ({\n        [this.documentVariableName]: d.pageContent,\n        ...rest\n      }));\n      const promises = inputs.map(async i => {\n        const prompt = await this.llmChain.prompt.format(i);\n        return this.llmChain.llm.getNumTokens(prompt);\n      });\n      const length = await Promise.all(promises).then(results => results.reduce((a, b) => a + b, 0));\n      const canSkipMapStep = i !== 0 || !this.ensureMapStep;\n      const withinTokenLimit = length < this.maxTokens;\n      if (canSkipMapStep && withinTokenLimit) {\n        break;\n      }\n      const results = await this.llmChain.apply(inputs);\n      const {\n        outputKey\n      } = this.llmChain;\n      currentDocs = results.map(r => ({\n        pageContent: r[outputKey]\n      }));\n    }\n    const newInputs = {\n      input_documents: currentDocs,\n      ...rest\n    };\n    const result = await this.combineDocumentChain.call(newInputs);\n    return result;\n  }\n  _chainType() {\n    return \"map_reduce_documents_chain\";\n  }\n  static async deserialize(data) {\n    if (!data.llm_chain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n    if (!data.combine_document_chain) {\n      throw new Error(\"Missing combine_document_chain\");\n    }\n    return new MapReduceDocumentsChain({\n      llmChain: await LLMChain.deserialize(data.llm_chain),\n      combineDocumentChain: await BaseChain.deserialize(data.combine_document_chain)\n    });\n  }\n  serialize() {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n      combine_document_chain: this.combineDocumentChain.serialize()\n    };\n  }\n}","map":{"version":3,"names":["BaseChain","LLMChain","StuffDocumentsChain","inputKeys","inputKey","llmChain","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","documentVariableName","outputKey","_call","values","Error","docs","rest","texts","map","_ref","pageContent","text","join","result","call","_chainType","deserialize","data","llm_chain","serialize","_type","MapReduceDocumentsChain","combineDocumentChain","ensureMapStep","maxTokens","maxIterations","currentDocs","i","inputs","d","promises","prompt","format","llm","getNumTokens","length","Promise","all","then","results","reduce","a","b","canSkipMapStep","withinTokenLimit","apply","r","newInputs","input_documents","combine_document_chain"],"sources":["/Users/b/Code/langchainjs/langchain/dist/chains/combine_docs_chain.js"],"sourcesContent":["import { BaseChain } from \"./base.js\";\nimport { LLMChain } from \"./llm_chain.js\";\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class StuffDocumentsChain extends BaseChain {\n    get inputKeys() {\n        return [this.inputKey, ...this.llmChain.inputKeys];\n    }\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input_documents\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output_text\"\n        });\n        Object.defineProperty(this, \"documentVariableName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"context\"\n        });\n        this.llmChain = fields.llmChain;\n        this.documentVariableName =\n            fields.documentVariableName ?? this.documentVariableName;\n        this.inputKey = fields.inputKey ?? this.inputKey;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n    }\n    async _call(values) {\n        if (!(this.inputKey in values)) {\n            throw new Error(`Document key ${this.inputKey} not found.`);\n        }\n        const { [this.inputKey]: docs, ...rest } = values;\n        const texts = docs.map(({ pageContent }) => pageContent);\n        const text = texts.join(\"\\n\\n\");\n        const result = await this.llmChain.call({\n            ...rest,\n            [this.documentVariableName]: text,\n        });\n        return result;\n    }\n    _chainType() {\n        return \"stuff_documents_chain\";\n    }\n    static async deserialize(data) {\n        if (!data.llm_chain) {\n            throw new Error(\"Missing llm_chain\");\n        }\n        return new StuffDocumentsChain({\n            llmChain: await LLMChain.deserialize(data.llm_chain),\n        });\n    }\n    serialize() {\n        return {\n            _type: this._chainType(),\n            llm_chain: this.llmChain.serialize(),\n        };\n    }\n}\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class MapReduceDocumentsChain extends BaseChain {\n    get inputKeys() {\n        return [this.inputKey, ...this.combineDocumentChain.inputKeys];\n    }\n    constructor(fields) {\n        super();\n        Object.defineProperty(this, \"llmChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input_documents\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output_text\"\n        });\n        Object.defineProperty(this, \"documentVariableName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"context\"\n        });\n        Object.defineProperty(this, \"maxTokens\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3000\n        });\n        Object.defineProperty(this, \"maxIterations\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 10\n        });\n        Object.defineProperty(this, \"ensureMapStep\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"combineDocumentChain\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.llmChain = fields.llmChain;\n        this.combineDocumentChain = fields.combineDocumentChain;\n        this.documentVariableName =\n            fields.documentVariableName ?? this.documentVariableName;\n        this.ensureMapStep = fields.ensureMapStep ?? this.ensureMapStep;\n        this.inputKey = fields.inputKey ?? this.inputKey;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n        this.maxTokens = fields.maxTokens ?? this.maxTokens;\n        this.maxIterations = fields.maxIterations ?? this.maxIterations;\n    }\n    async _call(values) {\n        if (!(this.inputKey in values)) {\n            throw new Error(`Document key ${this.inputKey} not found.`);\n        }\n        const { [this.inputKey]: docs, ...rest } = values;\n        let currentDocs = docs;\n        for (let i = 0; i < this.maxIterations; i += 1) {\n            const inputs = currentDocs.map((d) => ({\n                [this.documentVariableName]: d.pageContent,\n                ...rest,\n            }));\n            const promises = inputs.map(async (i) => {\n                const prompt = await this.llmChain.prompt.format(i);\n                return this.llmChain.llm.getNumTokens(prompt);\n            });\n            const length = await Promise.all(promises).then((results) => results.reduce((a, b) => a + b, 0));\n            const canSkipMapStep = i !== 0 || !this.ensureMapStep;\n            const withinTokenLimit = length < this.maxTokens;\n            if (canSkipMapStep && withinTokenLimit) {\n                break;\n            }\n            const results = await this.llmChain.apply(inputs);\n            const { outputKey } = this.llmChain;\n            currentDocs = results.map((r) => ({\n                pageContent: r[outputKey],\n            }));\n        }\n        const newInputs = { input_documents: currentDocs, ...rest };\n        const result = await this.combineDocumentChain.call(newInputs);\n        return result;\n    }\n    _chainType() {\n        return \"map_reduce_documents_chain\";\n    }\n    static async deserialize(data) {\n        if (!data.llm_chain) {\n            throw new Error(\"Missing llm_chain\");\n        }\n        if (!data.combine_document_chain) {\n            throw new Error(\"Missing combine_document_chain\");\n        }\n        return new MapReduceDocumentsChain({\n            llmChain: await LLMChain.deserialize(data.llm_chain),\n            combineDocumentChain: await BaseChain.deserialize(data.combine_document_chain),\n        });\n    }\n    serialize() {\n        return {\n            _type: this._chainType(),\n            llm_chain: this.llmChain.serialize(),\n            combine_document_chain: this.combineDocumentChain.serialize(),\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}