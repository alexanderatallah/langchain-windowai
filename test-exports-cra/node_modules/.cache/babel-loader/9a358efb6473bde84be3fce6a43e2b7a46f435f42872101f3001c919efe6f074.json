{"ast":null,"code":"import { BaseOutputParser, OutputParserException } from \"../schema/index.js\";\n/**\n * Class to parse the output of an LLM call into a dictionary.\n * @augments BaseOutputParser\n */\nexport class RegexParser extends BaseOutputParser {\n  constructor(regex, outputKeys, defaultOutputKey) {\n    super();\n    Object.defineProperty(this, \"regex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputKeys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"defaultOutputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.regex = regex;\n    this.outputKeys = outputKeys;\n    this.defaultOutputKey = defaultOutputKey;\n  }\n  _type() {\n    return \"regex_parser\";\n  }\n  async parse(text) {\n    const match = text.match(this.regex);\n    if (match) {\n      return this.outputKeys.reduce((acc, key, index) => {\n        acc[key] = match[index + 1];\n        return acc;\n      }, {});\n    }\n    if (this.defaultOutputKey === undefined) {\n      throw new OutputParserException(`Could not parse output: ${text}`);\n    }\n    return this.outputKeys.reduce((acc, key) => {\n      acc[key] = key === this.defaultOutputKey ? text : \"\";\n      return acc;\n    }, {});\n  }\n  getFormatInstructions() {\n    return `Your response should match the following regex: /${this.regex}/`;\n  }\n}","map":{"version":3,"names":["BaseOutputParser","OutputParserException","RegexParser","constructor","regex","outputKeys","defaultOutputKey","Object","defineProperty","enumerable","configurable","writable","value","_type","parse","text","match","reduce","acc","key","index","undefined","getFormatInstructions"],"sources":["/Users/b/Code/langchainjs/test-exports-cra/node_modules/langchain/dist/output_parsers/regex.js"],"sourcesContent":["import { BaseOutputParser, OutputParserException } from \"../schema/index.js\";\n/**\n * Class to parse the output of an LLM call into a dictionary.\n * @augments BaseOutputParser\n */\nexport class RegexParser extends BaseOutputParser {\n    constructor(regex, outputKeys, defaultOutputKey) {\n        super();\n        Object.defineProperty(this, \"regex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKeys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultOutputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.regex = regex;\n        this.outputKeys = outputKeys;\n        this.defaultOutputKey = defaultOutputKey;\n    }\n    _type() {\n        return \"regex_parser\";\n    }\n    async parse(text) {\n        const match = text.match(this.regex);\n        if (match) {\n            return this.outputKeys.reduce((acc, key, index) => {\n                acc[key] = match[index + 1];\n                return acc;\n            }, {});\n        }\n        if (this.defaultOutputKey === undefined) {\n            throw new OutputParserException(`Could not parse output: ${text}`);\n        }\n        return this.outputKeys.reduce((acc, key) => {\n            acc[key] = key === this.defaultOutputKey ? text : \"\";\n            return acc;\n        }, {});\n    }\n    getFormatInstructions() {\n        return `Your response should match the following regex: /${this.regex}/`;\n    }\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,qBAAqB,QAAQ,oBAAoB;AAC5E;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,SAASF,gBAAgB,CAAC;EAC9CG,WAAWA,CAACC,KAAK,EAAEC,UAAU,EAAEC,gBAAgB,EAAE;IAC7C,KAAK,EAAE;IACPC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE;MACtCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAC5CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACR,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;EAC5C;EACAO,KAAKA,CAAA,EAAG;IACJ,OAAO,cAAc;EACzB;EACA,MAAMC,KAAKA,CAACC,IAAI,EAAE;IACd,MAAMC,KAAK,GAAGD,IAAI,CAACC,KAAK,CAAC,IAAI,CAACZ,KAAK,CAAC;IACpC,IAAIY,KAAK,EAAE;MACP,OAAO,IAAI,CAACX,UAAU,CAACY,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAK;QAC/CF,GAAG,CAACC,GAAG,CAAC,GAAGH,KAAK,CAACI,KAAK,GAAG,CAAC,CAAC;QAC3B,OAAOF,GAAG;MACd,CAAC,EAAE,CAAC,CAAC,CAAC;IACV;IACA,IAAI,IAAI,CAACZ,gBAAgB,KAAKe,SAAS,EAAE;MACrC,MAAM,IAAIpB,qBAAqB,CAAE,2BAA0Bc,IAAK,EAAC,CAAC;IACtE;IACA,OAAO,IAAI,CAACV,UAAU,CAACY,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;MACxCD,GAAG,CAACC,GAAG,CAAC,GAAGA,GAAG,KAAK,IAAI,CAACb,gBAAgB,GAAGS,IAAI,GAAG,EAAE;MACpD,OAAOG,GAAG;IACd,CAAC,EAAE,CAAC,CAAC,CAAC;EACV;EACAI,qBAAqBA,CAAA,EAAG;IACpB,OAAQ,oDAAmD,IAAI,CAAClB,KAAM,GAAE;EAC5E;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}