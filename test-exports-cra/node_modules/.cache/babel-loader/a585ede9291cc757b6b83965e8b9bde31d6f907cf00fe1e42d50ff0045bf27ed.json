{"ast":null,"code":"import hash from \"object-hash\";\n/**\n * This cache key should be consistent across all versions of langchain.\n * It is currently NOT consistent across versions of langchain.\n *\n * A huge benefit of having a remote cache (like redis) is that you can\n * access the cache from different processes/machines. The allows you to\n * seperate concerns and scale horizontally.\n *\n * TODO: Make cache key consistent across versions of langchain.\n */\nconst getCacheKey = function () {\n  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {\n    strings[_key] = arguments[_key];\n  }\n  return hash(strings.join(\"_\"));\n};\nexport class BaseCache {}\nconst GLOBAL_MAP = new Map();\nexport class InMemoryCache extends BaseCache {\n  constructor(map) {\n    super();\n    Object.defineProperty(this, \"cache\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.cache = map ?? new Map();\n  }\n  lookup(prompt, llmKey) {\n    return Promise.resolve(this.cache.get(getCacheKey(prompt, llmKey)) ?? null);\n  }\n  async update(prompt, llmKey, value) {\n    this.cache.set(getCacheKey(prompt, llmKey), value);\n  }\n  static global() {\n    return new InMemoryCache(GLOBAL_MAP);\n  }\n}\n/**\n *\n * TODO: Generalize to support other types.\n */\nexport class RedisCache extends BaseCache {\n  constructor(redisClient) {\n    super();\n    Object.defineProperty(this, \"redisClient\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.redisClient = redisClient;\n  }\n  async lookup(prompt, llmKey) {\n    let idx = 0;\n    let key = getCacheKey(prompt, llmKey, String(idx));\n    let value = await this.redisClient.get(key);\n    const generations = [];\n    while (value) {\n      if (!value) {\n        break;\n      }\n      generations.push({\n        text: value\n      });\n      idx += 1;\n      key = getCacheKey(prompt, llmKey, String(idx));\n      value = await this.redisClient.get(key);\n    }\n    return generations.length > 0 ? generations : null;\n  }\n  async update(prompt, llmKey, value) {\n    for (let i = 0; i < value.length; i += 1) {\n      const key = getCacheKey(prompt, llmKey, String(i));\n      await this.redisClient.set(key, value[i].text);\n    }\n  }\n}","map":{"version":3,"names":["hash","getCacheKey","_len","arguments","length","strings","Array","_key","join","BaseCache","GLOBAL_MAP","Map","InMemoryCache","constructor","map","Object","defineProperty","enumerable","configurable","writable","value","cache","lookup","prompt","llmKey","Promise","resolve","get","update","set","global","RedisCache","redisClient","idx","key","String","generations","push","text","i"],"sources":["/Users/b/Code/langchainjs/langchain/dist/cache.js"],"sourcesContent":["import hash from \"object-hash\";\n/**\n * This cache key should be consistent across all versions of langchain.\n * It is currently NOT consistent across versions of langchain.\n *\n * A huge benefit of having a remote cache (like redis) is that you can\n * access the cache from different processes/machines. The allows you to\n * seperate concerns and scale horizontally.\n *\n * TODO: Make cache key consistent across versions of langchain.\n */\nconst getCacheKey = (...strings) => hash(strings.join(\"_\"));\nexport class BaseCache {\n}\nconst GLOBAL_MAP = new Map();\nexport class InMemoryCache extends BaseCache {\n    constructor(map) {\n        super();\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cache = map ?? new Map();\n    }\n    lookup(prompt, llmKey) {\n        return Promise.resolve(this.cache.get(getCacheKey(prompt, llmKey)) ?? null);\n    }\n    async update(prompt, llmKey, value) {\n        this.cache.set(getCacheKey(prompt, llmKey), value);\n    }\n    static global() {\n        return new InMemoryCache(GLOBAL_MAP);\n    }\n}\n/**\n *\n * TODO: Generalize to support other types.\n */\nexport class RedisCache extends BaseCache {\n    constructor(redisClient) {\n        super();\n        Object.defineProperty(this, \"redisClient\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.redisClient = redisClient;\n    }\n    async lookup(prompt, llmKey) {\n        let idx = 0;\n        let key = getCacheKey(prompt, llmKey, String(idx));\n        let value = await this.redisClient.get(key);\n        const generations = [];\n        while (value) {\n            if (!value) {\n                break;\n            }\n            generations.push({ text: value });\n            idx += 1;\n            key = getCacheKey(prompt, llmKey, String(idx));\n            value = await this.redisClient.get(key);\n        }\n        return generations.length > 0 ? generations : null;\n    }\n    async update(prompt, llmKey, value) {\n        for (let i = 0; i < value.length; i += 1) {\n            const key = getCacheKey(prompt, llmKey, String(i));\n            await this.redisClient.set(key, value[i].text);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}