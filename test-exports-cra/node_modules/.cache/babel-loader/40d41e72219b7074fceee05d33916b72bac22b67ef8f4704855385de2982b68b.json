{"ast":null,"code":"/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nexport const EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(stream, onChunk) {\n  const reader = stream.getReader();\n  let result;\n  // eslint-disable-next-line no-cond-assign\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value);\n  }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(onLine) {\n  let buffer;\n  let position; // current read position\n  let fieldLength; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* ControlChars.NewLine */) {\n          lineStart = ++position; // skip to next char\n        }\n\n        discardTrailingNewline = false;\n      }\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* ControlChars.Colon */:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case 13 /* ControlChars.CarriageReturn */:\n            discardTrailingNewline = true;\n          // eslint-disable-next-line no-fallthrough\n          case 10 /* ControlChars.NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(onMessage, onId, onRetry) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  // return a function that can process each incoming line buffer:\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId?.(message.id = value);\n          break;\n        case \"retry\":\n          {\n            const retry = parseInt(value, 10);\n            if (!Number.isNaN(retry)) {\n              // per spec, ignore non-integers\n              onRetry?.(message.retry = retry);\n            }\n            break;\n          }\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: undefined\n  };\n}","map":{"version":3,"names":["EventStreamContentType","getBytes","stream","onChunk","reader","getReader","result","read","done","value","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","undefined","concat","bufLength","length","lineStart","lineEnd","subarray","getMessages","onMessage","onId","onRetry","message","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","data","event","id","retry","parseInt","Number","isNaN","a","b","res","Uint8Array","set"],"sources":["/Users/b/Code/langchainjs/langchain/dist/util/event-source-parse.js"],"sourcesContent":["/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nexport const EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(stream, onChunk) {\n    const reader = stream.getReader();\n    let result;\n    // eslint-disable-next-line no-cond-assign\n    while (!(result = await reader.read()).done) {\n        onChunk(result.value);\n    }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr) {\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* ControlChars.NewLine */) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58 /* ControlChars.Colon */:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case 13 /* ControlChars.CarriageReturn */:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case 10 /* ControlChars.NewLine */:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        }\n        else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(onMessage, onId, onRetry) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength) {\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId?.((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = parseInt(value, 10);\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry?.((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}